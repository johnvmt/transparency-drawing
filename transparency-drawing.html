<template is="transparency-drawing">
	<style>
		:host {
			display: block;
			height: 100%;
			width: 100%;
		}
	</style>
	<div style="width: 100%; height: 100%;">
		<svg style="position: absolute; top: 0; left: 0; z-index: 1; width: 100%; height: 100%;" xmlns="http://www.w3.org/2000/svg">
			<defs>
				<filter id="drop-shadow">
					<feGaussianBlur in="SourceAlpha" stdDeviation="2.2"/>
					<feOffset dx="1" dy="1" result="offsetblur"/>
					<feFlood flood-color="rgba(0,0,0,0.5)"/>
					<feComposite in2="offsetblur" operator="in"/>
					<feMerge>
						<feMergeNode/>
						<feMergeNode in="SourceGraphic"/>
					</feMerge>
				</filter>
			</defs>
			<g id="drawings"></g>
		</svg>
		<slot style="position: relative; top: -100%; left: 0; z-index: 0; width: 100%; height: 100%;"></slot>
	</div>
</template>

<script>
	(function() {
		let componentDoc =  (document._currentScript || document.currentScript).ownerDocument;
		let componentDir = componentDoc.baseURI.substring(0, componentDoc.baseURI.lastIndexOf('/'));
		let componentFile = componentDoc.baseURI.substring(componentDoc.baseURI.lastIndexOf('/') + 1);
		let componentName = componentFile.substring(0, componentFile.lastIndexOf('.'));

		class TransparencyDrawing extends HTMLElement {

			constructor() {
				super(); // Always call super first in constructor

				let thisElem = this;

				thisElem._emitEvents = true;

				// Gets content from <template>
				let shadow = this.attachShadow({mode: 'open'});
				let template = componentDoc.querySelector('template[is=transparency-drawing]').content;
				shadow.appendChild(document.importNode(template, true));

				this._elements = {
					svg: shadow.querySelector('svg'),
					canvas: shadow.querySelector('#touchcanvas')
				};

				this._paths = {};
				this._images = {};

				if(this.hasAttribute('passthrough'))
					this.passthrough(this.getAttribute('passthrough'));
			}

			connectedCallback() {
				this._elements.drawings = this.shadowRoot.querySelector('svg #drawings');
				this.addCanvasTouchHandlers();
			}

			static get observedAttributes() {
				return ['passthrough'];
			}

			attributeChangedCallback(attributeName, oldVal, newVal) {
				if(attributeName == 'passthrough' && oldVal != newVal)
					this.passthrough(newVal);
			};

			clear(mirrorTag) {
				let drawingsNode = this._elements.drawings;
				while (drawingsNode.firstChild) {
					drawingsNode.removeChild(drawingsNode.firstChild);
				}

				this.emitMirror(mirrorTag, 'clear', arguments);
			};

			passthroughAndClear(passthrough, mirrorTag) {
				this.clear();
				this.passthrough(passthrough, mirrorTag);
			}

			passthrough(passthrough, mirrorTag) {
				if(typeof passthrough == 'string' && passthrough.toLowerCase() == 'false')
					passthrough = false;

				if(typeof passthrough != 'boolean')
					passthrough = Boolean(passthrough);

				this._elements.svg.style['pointer-events'] = passthrough ? "none" : "auto";

				this.setAttribute('passthrough', passthrough);

				this.emitMirror(mirrorTag, 'passthrough', [passthrough]);
			}

			removeImage(imageId, mirrorTag) {
				if(typeof this._images[imageId] == 'object') {
					this._images[imageId].parentNode.removeChild(this._images[imageId]);
					delete this._images[imageId];
					this.emitMirror(mirrorTag, 'removeImage', arguments);
				}
			};

			addImage(percentageX, percentageY) {
				// Capture path attributes from element attributes
				let imageAttributes = {};
				let imageAttributeKeyPrefix = 'image-'; // capture all attributes that start with path-

				this._objectForEach(this.getAttributes(), function(attributeVal, attributeKey) {
					if(attributeKey.indexOf(imageAttributeKeyPrefix) == 0)
						imageAttributes[attributeKey.slice(imageAttributeKeyPrefix.length)] = attributeVal;
				});

				let imageAttributesDefault = {
					'filter': 'url(#drop-shadow)'
				};

				imageAttributes = this._objectExtend(imageAttributesDefault, imageAttributes); // Merge defaults with passed params

				let imageId = this._uniqueId();
				this.addImageStyle(imageId, imageAttributes, percentageX, percentageY);
			};

			addImageStyle(imageId, imageAttributes, percentageX, percentageY, mirrorTag) {
				let elem = this;
				let coordinateX = percentageX * this.clientWidth;
				let coordinateY = percentageY * this.clientHeight;

				let drawingsNode = this._elements.drawings;

				// Capture image-* attributes from element attributes
				let pathAttributes = {};
				let pathAttributeKeyPrefix = 'path-'; // capture all attributes that start with path-
				elem._objectForEach(this.getAttributes(), function(attributeVal, attributeKey) {
					if(attributeKey.indexOf(pathAttributeKeyPrefix) == 0)
						pathAttributes[attributeKey.slice(pathAttributeKeyPrefix.length)] = attributeVal;
				});

				let imageNode = document.createElementNS('http://www.w3.org/2000/svg','image');

				// Set the image src
				imageNode.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', imageAttributes['href']);

				// Support percentages
				let imageWidth = 0;
				let imageHeight = 0;
				if(imageAttributes.width[imageAttributes.width.length - 1] == '%') {
					imageWidth = this.clientWidth * (parseFloat(imageAttributes.width.replace(/[^\d.-]/g, '')) / 100);
				}
				else {
					imageWidth = parseFloat(imageAttributes.width.replace(/[^\d.-]/g, ''));
				}

				// Support percentages
				if(imageAttributes.height[imageAttributes.height.length - 1] == '%') {
					imageHeight = this.clientHeight * (parseFloat(imageAttributes.height.replace(/[^\d.-]/g, '')) / 100);
				}
				else {
					imageHeight = parseFloat(imageAttributes.height.replace(/[^\d.-]/g, ''));
				}

				imageNode.setAttribute('x', coordinateX - (imageWidth / 2));
				imageNode.setAttribute('y', coordinateY - (imageHeight / 2));

				imageNode.setAttribute('width', imageWidth);
				imageNode.setAttribute('height', imageHeight);

				elem._objectForEach(imageAttributes, function(attributeVal, attributeKey) {
					if(['href', 'width', 'height', 'id'].indexOf(attributeKey) < 0)
						imageNode.setAttribute(attributeKey, attributeVal);
				});

				/*
				 var imageAnimationNode = document.createElementNS('http://www.w3.org/2000/svg','animateTransform');
				 imageAnimationNode.setAttribute('attributeType', "XML");
				 imageAnimationNode.setAttribute('attributeName', "transform");
				 imageAnimationNode.setAttribute('type', "scale");
				 imageAnimationNode.setAttribute('from', "0");
				 imageAnimationNode.setAttribute('to', "1");
				 imageAnimationNode.setAttribute('dur', "10s");
				 imageAnimationNode.setAttribute('repeatCount', "indefinite");
				 imageNode.appendChild(imageAnimationNode);
				 */

				// Add handlers to remove image

				imageNode.addEventListener('mousedown',function(event) {
					event.stopPropagation();
					event.preventDefault();
					elem.removeImage(imageId);
				});

				imageNode.addEventListener('touchstart',function(event) {
					event.stopPropagation();
					event.preventDefault();
					elem.removeImage(imageId);
				});

				elem._images[imageId] = imageNode;
				drawingsNode.appendChild(imageNode);

				this.emitMirror(mirrorTag, 'addImageStyle', arguments);
			};

			// Collector function to start a path
			// Gather path attributes and pass to drawing function
			startPath(id, percentageX, percentageY) {
				// Capture path attributes from element attributes
				let pathAttributes = {};
				let pathAttributeKeyPrefix = 'path-'; // capture all attributes that start with path-
				this._objectForEach(this.getAttributes(), function(attributeVal, attributeKey) {
					if(attributeKey.indexOf(pathAttributeKeyPrefix) == 0)
						pathAttributes[attributeKey.slice(pathAttributeKeyPrefix.length)] = attributeVal;
				});

				let pathAttributesDefault = {
					'fill': 'transparent',
					'stroke': 'red',
					'stroke-width': '10',
					'stroke-linecap': 'round',
					'filter': 'url(#drop-shadow)'
				};

				pathAttributes = this._objectExtend(pathAttributesDefault, pathAttributes); // Merge defaults with passed params

				this.startPathStyle(id, pathAttributes, percentageX, percentageY);
			};

			startPathStyle(id, pathAttributes, percentageX, percentageY, mirrorTag) {
				let coordinateX = percentageX * this.clientWidth;
				let coordinateY = percentageY * this.clientHeight;

				let drawingsNode = this._elements.drawings;

				let pathNode = document.createElementNS('http://www.w3.org/2000/svg','path');
				pathNode.setAttribute('d', 'M' + coordinateX.toString() + ',' + coordinateY.toString());

				this._objectForEach(pathAttributes, function(attributeVal, attributeKey) {
					pathNode.setAttribute(attributeKey, attributeVal);
				});

				drawingsNode.appendChild(pathNode);

				this._paths[id] = pathNode;

				this.emitMirror(mirrorTag, 'startPathStyle', arguments);
			};

			extendPath(id, percentageX, percentageY, mirrorTag) {
				// TODO fix this
				let coordinateX = percentageX * this.shadowRoot.querySelector('svg').clientWidth;
				let coordinateY = percentageY * this.shadowRoot.querySelector('svg').clientHeight;

				if(typeof this._paths[id] == 'object') {
					let pathNode = this._paths[id];
					pathNode.setAttribute('d', pathNode.getAttribute('d') + ' ' + coordinateX + ',' + coordinateY);
					this.emitMirror(mirrorTag, 'extendPath', arguments);
				}
			};

			endPath(id, percentageX, percentageY, mirrorTag) {
				if(typeof this._paths[id] == 'object')
					delete this._paths[id];
				this.emitMirror(mirrorTag, 'endPath', arguments);
			};

			emitMirror(mirrorTag, functionName, functionArgs) {
				if(typeof functionArgs == 'undefined')
					functionArgs = [];

				let emitMirrorDetail = {function: functionName, arguments: Array.prototype.slice.call(functionArgs)};
				if(typeof mirrorTag != 'undefined')
					emitMirrorDetail.tag = mirrorTag;

				let emitEvent = document.createEvent('CustomEvent');
				emitEvent.initCustomEvent('mirror', true, true, emitMirrorDetail);
				this.dispatchEvent(emitEvent);
			};

			addCanvasTouchHandlers() {
				let elem = this;
				let canvas = elem;

				function getMode() {
					let mode = elem.getAttribute('mode');
					return (mode == undefined) ? 'path' : mode;
				}

				function mouseHandler(event) {
					event.stopPropagation();
					event.preventDefault();
					let id = 'mouse';
					let mode = getMode();

					let canvasBoundingClientRect = canvas.getBoundingClientRect();

					let eventX = event.clientX - canvasBoundingClientRect.left;
					let eventY = event.clientY - canvasBoundingClientRect.top;

					let eventPercentageX = eventX / elem.shadowRoot.querySelector('svg').clientWidth;
					let eventPercentageY = eventY / elem.shadowRoot.querySelector('svg').clientHeight;

					switch(mode) {
						case 'image':
							switch(event.type) {
								case 'mousedown':
									elem.addImage(eventPercentageX, eventPercentageY);
									break;
							}
							break;
						case 'path':
							switch(event.type) {
								case 'mousedown':
									elem.startPath(id, eventPercentageX, eventPercentageY);
									elem.mousedown = true;
									break;
								case 'mousemove':
									if(typeof elem.mousedown == 'boolean' && elem.mousedown)
										elem.extendPath(id, eventPercentageX, eventPercentageY);
									break;
								case 'mouseup':
									if(elem.mousedown) {
										elem.mousedown = false;
										elem.endPath(id, eventPercentageX, eventPercentageY);
									}
									break;
							}
							break;
					}
				}

				function touchHandler(event) {
					event.stopPropagation();
					event.preventDefault();
					let mode = getMode();
					let canvasBoundingClientRect = canvas.getBoundingClientRect();

					elem._objectForEach(event.changedTouches, function(touch) {
						let id = touch.identifier.toString();

						let eventX = touch.clientX - canvasBoundingClientRect.left;
						let eventY = touch.clientY - canvasBoundingClientRect.top;

						let eventPercentageX = eventX / elem.clientWidth;
						let eventPercentageY = eventY / elem.clientHeight;

						switch(mode) {
							case 'image':
								switch(event.type) {
									case 'touchstart':
										elem.addImage(eventPercentageX, eventPercentageY);
										break;
								}
								break;
							case 'path':
								switch (event.type) {
									case 'touchstart':
										elem.startPath(id, eventPercentageX, eventPercentageY);
										break;
									case 'touchmove':
										elem.extendPath(id, eventPercentageX, eventPercentageY);
										break;
									case 'touchend':
										elem.endPath(id, eventPercentageX, eventPercentageY);
										break;
								}
								break;
						}
					});
				}

				canvas.addEventListener('mousedown', mouseHandler, false);
				canvas.addEventListener('mousemove', mouseHandler, false);
				window.addEventListener('mouseup', mouseHandler, false);
				canvas.addEventListener('touchstart', touchHandler, false);
				canvas.addEventListener('touchmove', touchHandler, false);
				canvas.addEventListener('touchend', touchHandler, false);
			};

			_objectExtend() {
				let merged = {};
				this._objectForEach(arguments, function(argument) {
					for(let attrname in argument) {
						if(argument.hasOwnProperty(attrname))
							merged[attrname] = argument[attrname];
					}
				});
				return merged;

			}

			_objectForEach(object, callback) {
				// run function on each property (child) of object
				for(let property in object) { // pull keys before looping through?
					if (object.hasOwnProperty(property))
						callback(object[property], property, object);
				}
			}

			_uniqueId() {
				function s4() {
					return Math.floor((1 + Math.random()) * 0x10000)
						.toString(16)
						.substring(1);
				}
				return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
					s4() + '-' + s4() + s4() + s4();
			}

			getAttributes(target) {
				if(typeof target === 'undefined')
					target = this;
				let attributes = {};
				for(let ctr = 0; ctr < target.attributes.length; ctr++) {
					attributes[target.attributes[ctr].nodeName] = target.attributes[ctr].nodeValue;
				}
				return attributes;
			};
		}

		customElements.define('transparency-drawing', TransparencyDrawing);
	})();
</script>