<template>
	<style>
		.layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}
		#canvas {
			z-index: 2;
		}
		svg {
			z-index: 1;
		}
	</style>
	<div>
		<div id="canvas" class="layer"></div>
		<svg class="layer" xmlns="http://www.w3.org/2000/svg">
			<defs>
				<filter id="drop-shadow">
					<feGaussianBlur in="SourceAlpha" stdDeviation="2.2"/>
					<feOffset dx="1" dy="1" result="offsetblur"/>
					<feFlood flood-color="rgba(0,0,0,0.5)"/>
					<feComposite in2="offsetblur" operator="in"/>
					<feMerge>
						<feMergeNode/>
						<feMergeNode in="SourceGraphic"/>
					</feMerge>
				</filter>
			</defs>
			<g id="drawings"></g>
		</svg>
	</div>
</template>

<!-- Event Emitter. Installed by Bower. Remove if not needed -->
<script type="text/javascript" src="../eventEmitter/EventEmitter.min.js"></script>

<script>
	(function(window, document) {
		// Create references to this file and directory
		var componentDoc =  (document._currentScript || document.currentScript).ownerDocument;
		var componentDir = componentDoc.baseURI.substring(0, componentDoc.baseURI.lastIndexOf('/'));
		var componentFile = componentDoc.baseURI.substring(componentDoc.baseURI.lastIndexOf('/') + 1);
		var componentName = componentFile.substring(0, componentFile.lastIndexOf('.'));

		// Gets content from <template>
		var template = componentDoc.querySelector('template').content;

		// Set default element attributes
		var elementAttributesDefault = {};

		// Object constructor (but most should go into createdCalledback)
		function Element() {

		}

		// Inherits from HTMLElement
		Element.prototype = Object.create(HTMLElement.prototype);

		// Add EventEmitter; Remove if not needed
		for(var key in EventEmitter.prototype) {
			Element.prototype[key] = EventEmitter.prototype[key];
		}

		Element.prototype.clearPaths = function() {
			var drawingsNode = this._elements.drawings;
			while (drawingsNode.firstChild) {
				drawingsNode.removeChild(drawingsNode.firstChild);
			}

			this.emitMirror('clearPaths', arguments);
		};

		// Collector function to start a path
		// Gather path attributes and pass to drawing function
		Element.prototype.startPath = function(id, percentageX, percentageY) {

			// Capture path attributes from element attributes
			var pathAttributes = {};
			var pathAttributeKeyPrefix = 'path-'; // capture all attributes that start with path-
			objectForEach(this.getAttributes(), function(attributeVal, attributeKey) {
				if(attributeKey.indexOf(pathAttributeKeyPrefix) == 0)
					pathAttributes[attributeKey.slice(pathAttributeKeyPrefix.length)] = attributeVal;
			});

			var pathAttributesDefault = {
				'fill': 'transparent',
				'stroke': 'red',
				'stroke-width': '10',
				'stroke-linecap': 'round',
				'filter': 'url(#drop-shadow)'
			};

			pathAttributes = objectExtend(pathAttributesDefault, pathAttributes); // Merge defaults with passed params

			this.startPathStyle(id, pathAttributes, percentageX, percentageY);
		};

		Element.prototype.startPathStyle = function(id, pathAttributes, percentageX, percentageY) {
			var coordinateX = percentageX * this.clientWidth;
			var coordinateY = percentageY * this.clientHeight;

			var drawingsNode = this._elements.drawings;

			var pathNode = document.createElementNS('http://www.w3.org/2000/svg','path');
			pathNode.setAttribute('d', 'M' + coordinateX.toString() + ',' + coordinateY.toString());

			objectForEach(pathAttributes, function(attributeVal, attributeKey) {
				pathNode.setAttribute(attributeKey, attributeVal);
			});

			drawingsNode.appendChild(pathNode);

			this._paths[id] = pathNode;

			this.emitMirror('startPathStyle', arguments);
		};

		Element.prototype.extendPath = function(id, percentageX, percentageY) {
			var coordinateX = percentageX * this.clientWidth;
			var coordinateY = percentageY * this.clientHeight;

			if(typeof this._paths[id] == 'object') {
				var pathNode = this._paths[id];
				pathNode.setAttribute('d', pathNode.getAttribute('d') + ' ' + coordinateX + ',' + coordinateY);
				this.emitMirror('extendPath', arguments);
			}
		};

		Element.prototype.endPath = function(id, percentageX, percentageY) {
			if(typeof this._paths[id] == 'object')
				delete this._paths[id];
			this.emitMirror('endPath', arguments);
		};

		Element.prototype.emitMirror = function(functionName, functionArgs) {
			this.emit.apply(this, ['mirror', functionName].concat(Array.prototype.slice.call(functionArgs)));
		};

		Element.prototype.addTouchHandlers = function() {
			var elem = this;
			var canvas = this._elements.canvas;

			function mouseHandler(event) {
				var id = 'mouse';

				var canvasBoundingClientRect = canvas.getBoundingClientRect();
				var eventX = event.clientX - canvasBoundingClientRect.left;
				var eventY = event.clientY - canvasBoundingClientRect.top;

				var eventPercentageX = eventX / elem.clientWidth;
				var eventPercentageY = eventY / elem.clientHeight;

				switch(event.type) {
					case 'mousedown':
						elem.startPath(id, eventPercentageX, eventPercentageY);
						elem.mousedown = true;
						break;
					case 'mousemove':
						if(typeof elem.mousedown == 'boolean' && elem.mousedown)
							elem.extendPath(id, eventPercentageX, eventPercentageY);
						break;
					case 'mouseup':
						elem.mousedown = false;
						elem.endPath(id, eventPercentageX, eventPercentageY);
						break;
				}
			}

			function touchHandler(event) {
				objectForEach(event.changedTouches, function(touch) {
					var id = touch.identifier.toString();

					var canvasBoundingClientRect = canvas.getBoundingClientRect();
					var eventX = touch.clientX - canvasBoundingClientRect.left;
					var eventY = touch.clientY - canvasBoundingClientRect.top;

					var eventPercentageX = eventX / elem.clientWidth;
					var eventPercentageY = eventY / elem.clientHeight;

					switch(event.type) {
						case 'touchstart':
							elem.startPath(id, eventPercentageX, eventPercentageY);
							event.preventDefault();
							break;
						case 'touchmove':
							elem.extendPath(id, eventPercentageX, eventPercentageY);
							event.preventDefault();
							break;
						case 'touchend':
							elem.endPath(id, eventPercentageX, eventPercentageY);
							break;
					}
				});
			}

			canvas.addEventListener('mousedown', mouseHandler, false);
			canvas.addEventListener('mousemove', mouseHandler, false);
			window.addEventListener('mouseup', mouseHandler, false);
			canvas.addEventListener('touchstart', touchHandler, false);
			canvas.addEventListener('touchmove', touchHandler, false);
			canvas.addEventListener('touchend', touchHandler, false);
		};


		// Fires when an instance of the element is created
		Element.prototype.createdCallback = function() {
			// Creates the shadow root
			this.shadowRoot = this.createShadowRoot();

			// Adds a template clone into shadow root
			this.shadowRoot.appendChild(document.importNode(template, true));

			this._elements = {
				'canvas': this.shadowRoot.querySelector('#canvas'),
				'drawings': this.shadowRoot.querySelector('svg #drawings')
			};

			this._paths = {};

			// get and merge params from bullet-point element
			this.elementAttributes = objectExtend(elementAttributesDefault, this.getAttributes());

			// Set up observer on children and character data. Remove if not needed
			var thisElem = this;
			addElementObserver(this, ['childList', 'characterData', 'subtree', 'attributeOldValue'], function(mutationRecords) {
				mutationRecords.forEach(function(mutationRecord) {
					// Ignore changes to thisElem attributes, as these are handled by attributeChangedCallback
					if(mutationRecord.target !== thisElem || mutationRecord.type !== 'attributes')
						thisElem.childMutatedCallback(mutationRecord);
				});
			});

			// Triggered when the window is resized
			window.addEventListener('resize', function() {

			});

			this.addTouchHandlers();
		};

		// Called when an attribute of this element is added, removed, or updated
		Element.prototype.attributeChangedCallback = function(attr, oldVal, newVal) {

		};

		// Called when an attribute in a child element is changed; uses child observer
		Element.prototype.childAttributeChangedCallback = function(target, attr, oldVal, newVal) {

		};

		// Called when a child element is added; uses child observer
		Element.prototype.childAddedCallback = function(child) {

		};

		// Called when a child element is removed; uses child observer
		Element.prototype.childRemovedCallback = function(child) {

		};

		// Called when a child element (child) is added to a child of this (target); uses child observer
		Element.prototype.descendantAddedCallback = function(target, child) {

		};

		// alled when a descendant element (child) is removed from a child of this (target); uses child observer
		Element.prototype.descendantRemovedCallback = function(target, child) {

		};

		// Called when element's innerHtml is changed; uses child observer
		Element.prototype.characterDataChangedCallback = function(newData) {

		};

		// Called when a child element is changed; uses child observer
		Element.prototype.childMutatedCallback = function(mutationRecord) {
			switch(mutationRecord.type) {
				case "childList":
					//console.log(mutationRecord);
					if(mutationRecord.target === this) { // Direct descendant
						for(var ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
							this.childAddedCallback(mutationRecord.addedNodes[ctr]);
						for(ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
							this.childRemovedCallback(mutationRecord.removedNodes[ctr]);
					}
					else {
						for(var ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
							this.descendantAddedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
						for(ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
							this.descendantRemovedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
					}
					break;
				case "attributes":
					this.childAttributeChangedCallback(mutationRecord.target, mutationRecord.attributeName, mutationRecord.oldValue, this.getAttribute(mutationRecord.attributeName, mutationRecord.target));
					break;
				case "characterData":
					this.characterDataChangedCallback(mutationRecord.target.data);
					break;
			}
		};

		/* Component utility Functions */
		// Get all attributes of element
		Element.prototype.getAttributes = function(target) {
			if(typeof target === 'undefined')
				target = this;

			var attributes = {};
			for(var ctr = 0; ctr < target.attributes.length; ctr++) {
				attributes[target.attributes[ctr].nodeName] = target.attributes[ctr].nodeValue;
			}
			return attributes;
		};

		Element.prototype.getAttribute = function(attributeName, target) {
			if(typeof target === 'undefined')
				target = this;

			for(var ctr = 0; ctr < target.attributes.length; ctr++) {
				if(target.attributes[ctr].nodeName === attributeName)
					return target.attributes[ctr].nodeValue;
			}
			return undefined;
		};

		/* Utility Functions */
		// Add observers to an element
		function addElementObserver(element, mutations, listener) {
			// possible mutations: 	attributes, childList, characterData
			var observer = new MutationObserver(listener);

			if(mutations.length > 0) {
				var observerConfig = {};
				for(var mutationIndex = 0; mutationIndex < mutations.length; mutationIndex++) {
					observerConfig[mutations[mutationIndex]] = true;
				}
				observer.observe(element, observerConfig);
			}

			return observer;
			// Returned observer can be removed with observer.disconnect()
		}

		// Add event triggers for an element
		function addElementEventListener(element, events, listener) {
			// if string (single event) passed, convert to Array
			if(!Array.isArray(events))
				events = [events];

			for(var eventIndex = 0; eventIndex < events.length; eventIndex++) {
				element.addEventListener(events[eventIndex], listener);
			}
		}

		// Return sum of all objects passed as new object, with later arguments overwriting
		function objectExtend() {
			var merged = {};
			objectForEach(arguments, function(argument) {
				for (var attrname in argument) {
					if(argument.hasOwnProperty(attrname))
						merged[attrname] = argument[attrname];
				}
			});
			return merged;

		}

		function objectForEach(object, callback) {
			// run function on each property (child) of object
			for(var property in object) { // pull keys before looping through?
				if (object.hasOwnProperty(property))
					callback(object[property], property, object);
			}
		}

		document.registerElement(componentName, Element);
	})(window, document);
</script>