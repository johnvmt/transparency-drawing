<template>
	<style>
		.layer {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
		}
		#canvas {
			background-color: rgba(0,0,255,0.5);
			z-index: 2;
		}
		svg {
			z-index: 1;
		}
	</style>
	<div>
		<div id="canvas" class="layer"></div>
		<svg class="layer" xmlns="http://www.w3.org/2000/svg">
			<defs>
				<filter id="drop-shadow">
					<feGaussianBlur in="SourceAlpha" stdDeviation="2.2"/>
					<feOffset dx="1" dy="1" result="offsetblur"/>
					<feFlood flood-color="rgba(0,0,0,0.5)"/>
					<feComposite in2="offsetblur" operator="in"/>
					<feMerge>
						<feMergeNode/>
						<feMergeNode in="SourceGraphic"/>
					</feMerge>
				</filter>
			</defs>
			<g id="drawings"></g>
		</svg>
	</div>
</template>

<!-- Event Emitter. Installed by Bower. Remove if not needed -->
<script type="text/javascript" src="bower_components/eventEmitter/EventEmitter.min.js"></script>

<script>
	(function(window, document) {
		// Create references to this file and directory
		var componentDoc =  (document._currentScript || document.currentScript).ownerDocument;
		var componentDir = componentDoc.baseURI.substring(0, componentDoc.baseURI.lastIndexOf('/'));
		var componentFile = componentDoc.baseURI.substring(componentDoc.baseURI.lastIndexOf('/') + 1);
		var componentName = componentFile.substring(0, componentFile.lastIndexOf('.'));

		// Gets content from <template>
		var template = componentDoc.querySelector('template').content;

		// Set default element attributes
		var elementAttributesDefault = {};

		// Object constructor (but most should go into createdCalledback)
		function Element() {

		}

		// Inherits from HTMLElement
		Element.prototype = Object.create(HTMLElement.prototype);

		// Add EventEmitter; Remove if not needed
		for(var key in EventEmitter.prototype) {
			Element.prototype[key] = EventEmitter.prototype[key];
		}


		Element.prototype.startPath = function(id, x, y) {
			var drawingsNode = this._elements.drawings;

			var pathNode = document.createElementNS('http://www.w3.org/2000/svg','path');
			pathNode.setAttribute('fill', 'transparent');
			pathNode.setAttribute('stroke', 'red');
			pathNode.setAttribute('stroke-width', '5');
			pathNode.setAttribute('filter', 'url(#drop-shadow)');
			pathNode.setAttribute('d', 'M' + x.toString() + ',' + y.toString());
			drawingsNode.appendChild(pathNode);
			this._paths[id] = pathNode;
		};

		Element.prototype.extendPath = function(id, x, y) {
			if(typeof this._paths[id] == 'object') {
				var pathNode = this._paths[id];
				pathNode.setAttribute('d', pathNode.getAttribute('d') + ' ' + x + ',' + y);
			}
		};

		Element.prototype.endPath = function(id, x, y) {
			if(typeof this._paths[id] == 'object')
				delete this._paths[id];
		};

		Element.prototype.addTouchHandlers = function() {
			var elem = this;
			var canvas = this._elements.canvas;

			function mouseHandler(event) {
				var id = 'mouse';
				var eventX = event.clientX - offsetLeft(canvas);
				var eventY = event.clientY - offsetTop(canvas);

				switch(event.type) {
					case 'mousedown':
						elem.startPath(id, eventX, eventY);
						elem.mousedown = true;
						break;
					case 'mousemove':
						if(typeof elem.mousedown == 'boolean' && elem.mousedown)
							elem.extendPath(id, eventX, eventY);
						break;
					case 'mouseup':
						elem.mousedown = false;
						elem.endPath(id, eventX, eventY);
						break;
				}
			}

			function touchHandler(event) {
				objectForEach(event.changedTouches, function(touch) {
					var id = touch.identifier.toString();

					var eventX = touch.clientX - offsetLeft(canvas);
					var eventY = touch.clientY - offsetTop(canvas);

					switch(event.type) {
						case 'touchstart':
							elem.startPath(id, eventX, eventY);
							event.preventDefault();
							break;
						case 'touchmove':
							elem.extendPath(id, eventX, eventY);
							event.preventDefault();
							break;
						case 'touchend':
							elem.endPath(id, eventX, eventY);
							break;
					}
				});
			}

			canvas.addEventListener('mousedown', mouseHandler, false);
			canvas.addEventListener('mousemove', mouseHandler, false);
			window.addEventListener('mouseup', mouseHandler, false);
			canvas.addEventListener('touchstart', touchHandler, false);
			canvas.addEventListener('touchmove', touchHandler, false);
			canvas.addEventListener('touchend', touchHandler, false);
		};


		// Fires when an instance of the element is created
		Element.prototype.createdCallback = function() {
			// Creates the shadow root
			this.shadowRoot = this.createShadowRoot();

			// Adds a template clone into shadow root
			this.shadowRoot.appendChild(document.importNode(template, true));

			this._elements = {
				'canvas': this.shadowRoot.querySelector('#canvas'),
				'drawings': this.shadowRoot.querySelector('svg #drawings')
			};

			this._paths = {};

			// get and merge params from bullet-point element
			this.elementAttributes = objectExtend(elementAttributesDefault, this.getAttributes());

			// Set up observer on children and character data. Remove if not needed
			var thisElem = this;
			addElementObserver(this, ['childList', 'characterData', 'subtree', 'attributeOldValue'], function(mutationRecords) {
				mutationRecords.forEach(function(mutationRecord) {
					// Ignore changes to thisElem attributes, as these are handled by attributeChangedCallback
					if(mutationRecord.target !== thisElem || mutationRecord.type !== 'attributes')
						thisElem.childMutatedCallback(mutationRecord);
				});
			});

			// Triggered when the window is resized
			window.addEventListener('resize', function() {

			});

			this.addTouchHandlers();
		};

		// Called when an attribute of this element is added, removed, or updated
		Element.prototype.attributeChangedCallback = function(attr, oldVal, newVal) {

		};

		// Called when an attribute in a child element is changed; uses child observer
		Element.prototype.childAttributeChangedCallback = function(target, attr, oldVal, newVal) {

		};

		// Called when a child element is added; uses child observer
		Element.prototype.childAddedCallback = function(child) {

		};

		// Called when a child element is removed; uses child observer
		Element.prototype.childRemovedCallback = function(child) {

		};

		// Called when a child element (child) is added to a child of this (target); uses child observer
		Element.prototype.descendantAddedCallback = function(target, child) {

		};

		// alled when a descendant element (child) is removed from a child of this (target); uses child observer
		Element.prototype.descendantRemovedCallback = function(target, child) {

		};

		// Called when element's innerHtml is changed; uses child observer
		Element.prototype.characterDataChangedCallback = function(newData) {

		};

		// Called when a child element is changed; uses child observer
		Element.prototype.childMutatedCallback = function(mutationRecord) {
			switch(mutationRecord.type) {
				case "childList":
					//console.log(mutationRecord);
					if(mutationRecord.target === this) { // Direct descendant
						for(var ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
							this.childAddedCallback(mutationRecord.addedNodes[ctr]);
						for(ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
							this.childRemovedCallback(mutationRecord.removedNodes[ctr]);
					}
					else {
						for(var ctr = 0; ctr < mutationRecord.addedNodes.length; ctr++)
							this.descendantAddedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
						for(ctr = 0; ctr < mutationRecord.removedNodes.length; ctr++)
							this.descendantRemovedCallback(mutationRecord.target, mutationRecord.addedNodes[ctr]);
					}
					break;
				case "attributes":
					this.childAttributeChangedCallback(mutationRecord.target, mutationRecord.attributeName, mutationRecord.oldValue, this.getAttribute(mutationRecord.attributeName, mutationRecord.target));
					break;
				case "characterData":
					this.characterDataChangedCallback(mutationRecord.target.data);
					break;
			}
		};

		/* Component utility Functions */
		// Get all attributes of element
		Element.prototype.getAttributes = function(target) {
			if(typeof target === 'undefined')
				target = this;

			var attributes = {};
			for(var ctr = 0; ctr < target.attributes.length; ctr++) {
				attributes[target.attributes[ctr].nodeName] = target.attributes[ctr].nodeValue;
			}
			return attributes;
		};

		Element.prototype.getAttribute = function(attributeName, target) {
			if(typeof target === 'undefined')
				target = this;

			for(var ctr = 0; ctr < target.attributes.length; ctr++) {
				if(target.attributes[ctr].nodeName === attributeName)
					return target.attributes[ctr].nodeValue;
			}
			return undefined;
		};

		/* Utility Functions */
		// Add observers to an element
		function addElementObserver(element, mutations, listener) {
			// possible mutations: 	attributes, childList, characterData
			var observer = new MutationObserver(listener);

			if(mutations.length > 0) {
				var observerConfig = {};
				for(var mutationIndex = 0; mutationIndex < mutations.length; mutationIndex++) {
					observerConfig[mutations[mutationIndex]] = true;
				}
				observer.observe(element, observerConfig);
			}

			return observer;
			// Returned observer can be removed with observer.disconnect()
		}

		// Add event triggers for an element
		function addElementEventListener(element, events, listener) {
			// if string (single event) passed, convert to Array
			if(!Array.isArray(events))
				events = [events];

			for(var eventIndex = 0; eventIndex < events.length; eventIndex++) {
				element.addEventListener(events[eventIndex], listener);
			}
		}

		// Return sum of all objects passed as new object, with later arguments overwriting
		function objectExtend() {
			var merged = {};
			objectForEach(arguments, function(argument) {
				for (var attrname in argument) {
					if(argument.hasOwnProperty(attrname))
						merged[attrname] = argument[attrname];
				}
			});
			return merged;

		}

		function objectForEach(object, callback) {
			// run function on each property (child) of object
			for(var property in object) { // pull keys before looping through?
				if (object.hasOwnProperty(property))
					callback(object[property], property, object);
			}
		}

		function offsetLeft(elem) {
			var offsetLeft = 0;
			do {
				if(!isNaN( elem.offsetLeft))
					offsetLeft += elem.offsetLeft;
			} while(elem = elem.offsetParent);
			return offsetLeft;
		}

		function offsetTop(elem) {
			var offsetTop = 0;
			do {
				if(!isNaN( elem.offsetTop))
					offsetTop += elem.offsetTop;
			} while(elem = elem.offsetParent);
			return offsetTop;
		}

		document.registerElement(componentName, Element);
	})(window, document);
</script>